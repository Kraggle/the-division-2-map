function pointDistance(ptA,ptB){const x=ptB.x-ptA.x,y=ptB.y-ptA.y;return Math.sqrt(x*x+y*y)}const computeSegmentHeading=(a,b)=>(180*Math.atan2(b.y-a.y,b.x-a.x)/Math.PI+90+360)%360,asRatioToPathLength=({value:value,isInPixels:isInPixels},totalPathLength)=>isInPixels?value/totalPathLength:value;function parseRelativeOrAbsoluteValue(value){if("string"==typeof value&&-1!==value.indexOf("%"))return{value:parseFloat(value)/100,isInPixels:!1};const parsedValue=value?parseFloat(value):0;return{value:parsedValue,isInPixels:parsedValue>0}}const pointsEqual=(a,b)=>a.x===b.x&&a.y===b.y;function pointsToSegments(pts){return pts.reduce((segments,b,idx,points)=>{if(idx>0&&!pointsEqual(b,points[idx-1])){const a=points[idx-1],distA=segments.length>0?segments[segments.length-1].distB:0,distAB=pointDistance(a,b);segments.push({a:a,b:b,distA:distA,distB:distA+distAB,heading:computeSegmentHeading(a,b)})}return segments},[])}function projectPatternOnPointPath(pts,pattern){const segments=pointsToSegments(pts),nbSegments=segments.length;if(0===nbSegments)return[];const totalPathLength=segments[nbSegments-1].distB,offset=asRatioToPathLength(pattern.offset,totalPathLength),endOffset=asRatioToPathLength(pattern.endOffset,totalPathLength),repeat=asRatioToPathLength(pattern.repeat,totalPathLength),repeatIntervalPixels=totalPathLength*repeat,startOffsetPixels=offset>0?totalPathLength*offset:0,endOffsetPixels=endOffset>0?totalPathLength*endOffset:0,positionOffsets=[];let positionOffset=startOffsetPixels;do{positionOffsets.push(positionOffset),positionOffset+=repeatIntervalPixels}while(repeatIntervalPixels>0&&positionOffset<totalPathLength-endOffsetPixels);let segmentIndex=0,segment=segments[0];return positionOffsets.map(positionOffset=>{for(;positionOffset>segment.distB&&segmentIndex<nbSegments-1;)segment=segments[++segmentIndex];const segmentRatio=(positionOffset-segment.distA)/(segment.distB-segment.distA);return{pt:interpolateBetweenPoints(segment.a,segment.b,segmentRatio),heading:segment.heading}})}function interpolateBetweenPoints(ptA,ptB,ratio){return ptB.x!==ptA.x?{x:ptA.x+ratio*(ptB.x-ptA.x),y:ptA.y+ratio*(ptB.y-ptA.y)}:{x:ptA.x,y:ptA.y+(ptB.y-ptA.y)*ratio}}
//# sourceMappingURL=patternUtils.min.js.map